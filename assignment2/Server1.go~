package main

import (
"fmt"
"log"
"net"
"net/rpc"
"time"
"math"
)


const (

DefaultHeartbeatInterval = 50 * time.Millisecond
DefaultElectionTimeout = 150 * time.Millisecond
)


type log [100]struct{
logIndex uint
logTerm uint
command []byte
}
Log log[]



type StateMachine struct{

	id int // server id
  status string
  peers []int // other server ids
  votedFor [10]int
	currentTerm uint64
	commitIndex uint64
	prevLogIndex uint64
	prevLogTerm uint64
	lastLogIndex uint64
	lastLogTerm uint64
	voteCount int
	voteRecieved [10]int
	nextIndex []int
	matchIndex []int
		        
}



//AppendEntries Request 
type AppendEntriesReqEv struct{
	term       uint64
	leaderId   unit64
	prevLogIndex unit64
	prevLogTerm  unit64
	entries[]  string
	leaderCommit unit64
       }



func (a *AppendEntriesReqEv ) AppendReqHandlerF( ){
       replyfalse := AppendEntriesResp(sm.currentTerm, false)
       replytrue := AppendEntriesResp(sm.currentTerm, true)

      if a.term<sm.currentTerm{
             send(a.leaderId,replyfalse)     
          }
      else{
        if a.entries==nil{
                Timeout(electionTimeout);
              }
    
        else{
     	       
	  
	    

	  if a.prevLogIndex != prevLogTerm && isEmpty(log's prevLogIndex entry){  
	      if prevlogIndex == 0{
       		      Generate the output action LogStore(index, entries[])
             	      send(leaderId,replytrue)
	       }else{
		      send(leaderId,replyfalse)
	       }
	      

	   }else if (sm.prevLogIndex==msg.prevLogIndex) && (sm.prevLogTerm != msg.prevLogTerm) && exists(log's prevLogIndex entry) {
         Delete the existing entry and those that follows trying to make its log equivalent to that of leader's
         Generate the output action 


	   }else if sm.lastLogIndex ==msg.prevLogIndex && sm.prevLogTerm == msg.prevLogIndex{
	      // Delete all the log entries following sm.prevLogIndex

        for i:=lastLogIndex+1;log[i].term!=nil&&i<100;i++{
              log[i].lastLogTerm=nil
              log[i].command=nil

        }

       
	      sm.lastLogIndex++

	      //Generate output action : LogStore(index, entries[])
	      
        LogStore(sm.lastLogIndex, a.entries)

        if a.leaderCommit>sm.commitIndex {
              sm.commitIndex = min(a.leaderCommit, sm.lastLogIndex)
	       }
	      
	      send(a.leaderId,replytrue);
		}

	}

}  

func (a *AppendEntriesReqEv ) AppendReqHandlerC( ){

     if(msg.term<sm.currentTerm)
     {
            send(leaderId,replyfalse)     
     }else{

          if(a.entries==nil)
           { 
              sm.status = "follower"
             // and change the state to follower as there must exists a leader for this term
        
           }
      }
}  

func (a *AppendEntriesReqEv ) AppendReqHandlerL( ){
     send(msg.leaderId, AppendEntriesResp(sm.currentTerm, false))
}     





//AppendEntries Response
type AppendEntriesRespEv struct{
	term int
	success bool
}
      
func (ar* AppendEntriesRespEv ) AppendEntriesresF(){


}

func (ar* AppendEntriesRespEv ) AppendEntriesresC(){



}

func (ar* AppendEntriesRespEv ) AppendEntriesresL(){



}




//AppendEv
type AppendEv struct{
   data1 []byte
}

func (ar* AppendEv ) AppendF(){



}

func (ar* AppendEv) AppendC(){



}

func (ar* AppendEv ) AppendL(){



}



//Timeout
type TimeoutEv struct{
 time uint64
}

func(t *TimeoutEv) timeoutHandlerF(){


}

func(t *TimeoutEv) timeoutHandlerC(){


}

func(t *TimeoutEv) timeoutHandlerL(){


}




//VoteRequest
type VoteRequestEv struct {
	peer *Peer
	term uint64
	lastLogIndex uint64
	lastLogTerm uint64
	candidateId string
      }

func(rv *VoteRequestEv) VoterequestF(){





}

func(rv *VoteRequestEv) VoterequestC(){





}

func(rv *VoteRequestEv) VoterequestL(){





}



//VoteResponse
type VoteResponseEv struct {
	peer *Peer
	term uint64
	voteGranted bool
       }


func (rvr *VoteResponseEv) VoteResponseHandlerF(){




}

func (rvr *VoteResponseEv) VoteResponseHandlerC(){




}

func (rvr *VoteResponseEv) VoteResponseHandlerL(){




}




//Process Event
func(sm *StateMachine) ProcessEvent(ev interface{}) []Action {
 switch ev.(type) {
 
        case AppendEntriesReqEv:
                cmd := ev.(AppendEntriesReqEv)
                if sm.status== "follower"{
                	cmd.AppendReqHandlerF( )     
                }else if sm.status=="candidate"{
                	cmd.AppendReqHandlerF( )
                }else if sm.status=="leader"{
			            cmd.AppendReqHandlerL( )                
                }
                
                
              
        case AppendEntriesRespEv:
                cmd := ev.(AppendEntriesRespEv)
        	      if sm.status== "follower"{
                	cmd.AppendEntriesresF()     
                }else if sm.status=="candidate"{
                	cmd.AppendEntriesresC()
                }else if sm.status=="leader"{
                	cmd.AppendEntriesresL()
                }
                

        
        case VoteReqEv:
                cmd := ev.(VoteReqEv)
                if sm.status== "follower"{
                	cmd.VoterequestF()
                }else if sm.status=="candidate"{
                	cmd.VoterequestC()
                }else if sm.status=="leader"{
                	cmd.VoterequestL()
                }
                
                
                // do stuff with req
                //fmt.Printf("%v\n", cmd)
        case VoteRespEv:
                cmd := ev.(VoteRespEv)
                if sm.status== "follower"{
                	cmd.VoteResponseHandlerF()
                }else if sm.status=="candidate"{
                	cmd.VoteResponseHandlerC()
                }else if sm.status=="leader"{
                	cmd.VoteResponseHandlerL()
                } 
                
                
        case AppendEv:
        	      cmd := ev.(AppendEv)
        	      if sm.status== "follower"{
                	cmd.AppendF()     
                }else if sm.status=="candidate"{
                	cmd.AppendC()
                }else if sm.status=="leader"{
                	cmd.AppendL()
                } 
                
                
        case TimeoutEv:
        	      cmd := ev.(TimeoutEv)
        	      if sm.status== "follower"{
                	cmd.timeoutHandlerF()     
                }else if sm.status=="candidate"{
                	cmd.timeoutHandlerC() 
                }else if sm.status=="leader"{
                	cmd.timeoutHandlerL() 
                } 
                
                          // other cases
        default: println ("Unrecognized")
        }
    
}




func main() {
var st StateMachine
/*st.status="follower"
addy, err := net.ResolveTCPAddr("tcp", "0.0.0.0:42586")
if err != nil {
log.Fatal(err)
}
inbound, err := net.ListenTCP("tcp", addy)
if err != nil {
log.Fatal(err)
}
StateMachine1 := new(StateMachine)
rpc.Register(StateMachine1)
rpc.Accept(inbound)
action[]=sm.ProcessEvent()*/
  st.term  =3
  st.leaderId =
  st.prevLogIndex =
  st.prevLogTerm  uni
  st.entries[] =
  st.leaderCommit =
sm.ProcessEvent(AppendEntriesReqEv{term : 10, prevLogIndex: 100, prevLogTerm: 3 entries:  leaderCommit : })





}


