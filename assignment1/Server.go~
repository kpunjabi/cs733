//server.go

package main

import (  
    "fmt"
    "net"
    "os"
    "strings"
    "io/ioutil"
    "strconv"
)

const (  
    CONN_HOST = "127.0.0.1"
    CONN_PORT = "8080"
    CONN_TYPE = "tcp"
)

type fileinfo [50]struct{
filename string
version int64
numbytes int
exptime int64
}
var c fileinfo
var clength int
func serverMain() {  
    // Listen for incoming connections.
    //var m map[string]int64
    //m["hello.go"]=0;
    c[0].filename="file1.txt"
    c[0].version=0
    c[0].numbytes=113
    c[0].exptime=500
    c[1].filename="file2.txt"
    c[1].version=0
    c[1].numbytes=89
    c[1].exptime=500
    clength=2
    l, err := net.Listen(CONN_TYPE, ":"+CONN_PORT)
    if err != nil {
        fmt.Println("Error listening:", err.Error())
        //os.Exit(1)
    }
   
    // Close the listener when the application closes.
    defer l.Close()
    fmt.Println("Listening on " + CONN_HOST + ":" + CONN_PORT)
    for {
        // Listen for an incoming connection.
        conn, err := l.Accept()
        if err != nil {
            fmt.Println("Error accepting: ", err.Error())
            //os.Exit(1)
        }
        
        // Handle connections in a new goroutine.
        go commandExecutor(conn)
     
    }
}

// Handles incoming requests.
func commandExecutor(conn net.Conn) { 
  var flag int
  flag=0 
  // Make a buffer to hold incoming data.
  buf := make([]byte, 2048)
  // Read the incoming connection into the buffer.
  Len, err := conn.Read(buf)
  if err != nil {
    fmt.Println("Error reading:", err.Error())
  }
  // Builds the message.
  fmt.Printf("%s",buf)
  s := string(buf[:Len])
  
  tok := strings.Split(s,"\r\n")
  stringtok := strings.Split(tok[0]," ")
  //fmt.Printf("%q\n",stringtok)
  if stringtok[0]=="read"{
  	t := strings.TrimSpace(stringtok[1])
  	dat, err := ioutil.ReadFile(t)
  //fmt.Println(stringtok[1])
  
     if err!=nil{
        conn.Write([]byte(err.Error()))
        //os.Exit(1)
       }
  conn.Write([]byte("CONTENTS "))
  for i := 0; i < 10; i++ {
  if c[i].filename==t{
  s := strconv.FormatInt(c[i].version,10)
  p := strconv.Itoa(c[i].numbytes)
  r := strconv.FormatInt(c[i].exptime,10)
  conn.Write([]byte(s+" "))
  conn.Write([]byte(p+" "))
  conn.Write([]byte(r+" "))
  conn.Write([]byte("\n"))
	}
  }
  
  conn.Write([]byte(dat))
  }else if stringtok[0]=="write"{
  if _, err := os.Stat(stringtok[1]); err == nil {
  //fmt.Println("File Alreay exists exists")
  flag = 1
}
  if flag != 1{
  c[clength].filename=stringtok[1]
  c[clength].numbytes, err=strconv.Atoi(strings.TrimSpace(stringtok[2]))
  c[clength].version=0
  c[clength].exptime, err=strconv.ParseInt(strings.TrimSpace(stringtok[3]), 10, 64)
  clength=clength+1
  }else if flag == 1 { 
  for i := 0 ; i<clength;i++{
  if c[i].filename == strings.TrimSpace(stringtok[1]){
  c[i].numbytes, err=strconv.Atoi(stringtok[2])
  c[i].exptime, err=strconv.ParseInt(stringtok[3], 10, 64)
   }
  }
 }
  //buf = nil;
  err := ioutil.WriteFile(stringtok[1], []byte(tok[1]), 0644)
  
  if err!=nil{
  conn.Write([]byte(err.Error()))
  //os.Exit(1)
  }
  conn.Write([]byte("OK"+"  "))
  for i:=0;i<=clength;i++{
  if c[i].filename == strings.TrimSpace(stringtok[1]){
  //fmt.Println([]byte(stringtok[1]))
  conn.Write([]byte(strconv.FormatInt(c[i].version,10)))
   }
   }
  conn.Close()
}else if stringtok[0]=="cas"{
if _, err := os.Stat(stringtok[1]); err == nil {
  fmt.Println("File Alreay exists exists")
  flag = 1
}
  if flag != 1{
  conn.Write([]byte("File does not exists\n"))
  }else if flag == 1{
   for i := 0 ; i<clength;i++{
  if c[i].filename== strings.TrimSpace(stringtok[1]){
  if strconv.FormatInt(c[i].version,10) == stringtok[2]{
  c[i].numbytes, err=strconv.Atoi(stringtok[3])
  c[i].exptime, err=strconv.ParseInt(stringtok[4], 10, 64)
  c[i].version++
  err := ioutil.WriteFile(stringtok[1], []byte(tok[1]), 0644)
   if err!=nil{
  conn.Write([]byte(err.Error()))
  //os.Exit(1)
  }
  }
  }
  }
 }
 conn.Write([]byte("OK"+"  "))
  for i:=0;i<clength;i++{
  if c[i].filename== strings.TrimSpace(stringtok[1]){
  conn.Write([]byte(strconv.FormatInt(c[i].version,10)))
   }
   }
  conn.Close()
}else if stringtok[0]=="delete"{
err := os.Remove(strings.TrimSpace(stringtok[1]))

      if err != nil {
          fmt.Println(err)
          return
      }
      for i:=0;i<clength;i++{
  if c[i].filename== strings.TrimSpace(stringtok[1]){
  c[i].filename="$"
  }
  }
  
conn.Close()
}
}
func main(){
serverMain()
}
